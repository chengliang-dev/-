1. C++虚函数与纯虚函数的区别
1.1 虚函数与纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，-而只含有虚函数的类不能被称为抽象类
1.2 虚函数可以被直接使用，也可以被子类重载之后一堕胎的形式使用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类中只有声明而未有定义
1.3 虚函数和纯虚函数都可以在子类中重载，以多态的形式调用
1.4 虚函数和纯虚函数通常存在于抽象基类中，被击沉的子类重载，目的是提供一个统一的接口
1.5 定义形式不同，虚函数:virtual {method body};纯虚函数：virtual {} = 0;
1.6 虚函数必须实现，如果不是先编译器将报错
1.7 对于虚函数来说，父类和子类都有各自的版本，由多态调用的时候静态绑定
1.8 如果一个类中含有纯虚函数，那么任何试图对该类进行时进行实例化的语句都将导致错误的产生，因为抽象类是不能被直接调用的。必须被子类继承重载以后，根据要求调用子类的方法
1.9 实现了纯虚函数的子类，该纯虚函数就在子类中变成了虚函数
1.10 虚函数与纯虚函数的定义中不能由static修饰，原因很简单，被static修饰的函数在编译时要求前期绑定，而虚函数是运行时绑定的，而且两者修饰的函数生命周期也不一样。


2. 哈希表的底层实现原理
两种：
数组+链表、数组加红黑树
线性探测、二次探测

3. 最短路径算法：
floyd算法
dijkstra算法
Bellman-Ford算法


4. new和delete的区别
4.1 new能够自动计算出需要分配的内存空间，而malloc需要手工计算字节数
4.2 new和delete直接返回具体类型的指针，malloc和free返回void类型指针
4.3 new是类型安全的，而malloc不是，例如int* p = new float[2]会报错;而int p = malloc(2*sizeof(int))编译时编译器就无法指出错误
4.4 new一般分为两步，new操作和构造。new操作对应于malloc，单new操作可以重载，可以自定义分配策略，不做内存分配，甚至分配到非内存设备上，malloc不行
    delete调用析构函数，而free不能
4.5 new 和delete是运算符，而malloc和free是库函数，不在编译期控制权限之内

函数重载（Overload):同类同名不同参数方法,发生在一个类中，方法名相同、参数列表不同，和返回值没有关系，发生在同一作用域中。
函数重写（Override):以继承为基础，只能发生在父类和子类之间，在子类和父类中相同声明的方法，返回值类型、方法名、参数列表完全相同，在运行期间根据具体对象的类型决定调用的函数。

5. 宏定义和函数的区别
5.1 宏在预处理阶段会被编译器替换掉，而且宏一般制作简单的文本替换，编译器不对其做任何的语法检测
------编译器在预处理的过程中进行宏替换时，一般进行如下三步：
1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，他们首先被替换；
2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换；
3. 最后，在此对结果文件进行扫描，看看她是否包含任何由#define定义的符号。如果是，就重复上述处理过程。
------注意：宏参数和#define在定义中可以出现其它#define定义的变量。但对于宏，不能出现递归
宏无法调试
宏是类型无关的，也就不够严谨
宏可能会带来运算符优先级的问题，导致程序易出错
5.2 内联函数与宏
内联函数与普通函数相比可以加快程序的运行速度，因为不需要中断调用，在编译时内联函数直接被镶嵌(指在调用函数的地方不是跳转而是把代码直接写到哪里去)在目标代码中，而宏只是在预编译中进行了简单的替换。
对于短小的代码来说inline增加空间消耗换来效率的提升，这方面和宏是一样的。贾少了普通函数调用时的资源消耗。关键字inline与函数定义体放在一起才能使函数成为内联
内联函数需要做类型检查。
5.3 宏和const
(1) 编译器处理方式不同
define宏实在预处理阶段展开
const常量是编译运行阶段使用
(2) 类型和安全检查不同
define宏没有类型，不做任何类型检查，仅仅是展开
const常量有具体的类型，在编译阶段会执行类型检查
(3) 存储方式不同
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存
const常量会在内存中分配

 6. main函数执行之前发生了什么
 1. 先通过编译链接生成.exe文件.(.exe文件在磁盘上存储，且.exe文件中是机器语言
 2. exe文件通过mmap函数映射到虚拟内存上
 3. 再通过分段分页机制把需要的指令与数据加载到内存上
 4. 把main函数的入口地址写入下一行指令寄存器中
 
 初始化系统相关资源
 1. 设置栈指针
 2. 初始化static静态和global全局变量，即data段的内容
 3. 将微垂花部分的赋初值：.bss段
 4. 运行全局构造器
 5. 将main函数的参数传递给main函数：argc,argv
 
 C++一个空类中包含什么  1字节的占位符，其对象也是1字节
 空的构造函数
 拷贝构造函数
 拷贝赋值函数
 析构函数
 取址运算符
 取址运算符 const
 这些函数只有在调用时才会被编译器创建出来
 
 C++多态是什么
 派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；
 而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。
 
 
C语言中
%3d表示是输出三位整型数，不够三位右对齐
%9.2f表示输出宽为9的浮点数，其中小数位为6位，整数位为6位，不够9位右对齐
%8s表示输出8个字符的字符串，不够8个字符串右对齐
如果字符串的长度、整形数位数超过说明的宽度，将按照实际位数输出

%-7d表示输出7位整数左对齐

数据库delete drop truncate
drop > truncate > delete
drop 语句会见那个表所占用的空间释放掉
truncate 一次性地从表中删除所有的数据并不把单独地删除操作就计入日志保存，删除行是不能恢复的。执行速度快   只能对Table
delete语句执行删除的过程是每次从表中删除一行，并且同时将改行地删除操作记录位十五记录在日志中保存以便进行回滚操作。  可以是table和view
